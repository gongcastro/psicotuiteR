---
title: "Creando {psicotuiteR}"
output: rmarkdown::html_vignette
author: Gonzalo Garcia-Castro (@gongcastro)
vignette: >
  %\VignetteIndexEntry{Creando {psicotuiteR}}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(psicotuiteR)
```

# ¿Qué es un paquete de R?

* Al programar, debemos evitar la repetición de código.
* Estructurar el código de forma jerárquica
1. Comando
2. Script
3. Función
4. Paquete
* Paquete: conjunto de funciones que realizan tareas diferentes pero relacionadas


# ¿Cuándo es buena idea hacer un paquete de R?

Generalmente hacemos un pqeute de R partiendo un script o grupo de funciones que, por razones de eficiencia o reproducibilidad, queremos agrupar, documentar y facilitar su instalación.


# Inicio

## ¿Qué necesito para hacer un paquete de R?


### {usethis}

{usethis} tiene muchísimas funciones muy útiles que empiezan por `use_*`. ¡Explóralas!

```r
install.packages(devtools)
install.packages(usethis)

library(usethis)
use_usethis()
use_devtools()
```

## .Rprofile

# Primeros pasos

## Creando un proyecto de RStudio

![](img/new_package.png)
![](img/package.png)
![](img/package_settings.png)

## Creando un paquete de R

```r
library(usethis)

create_package(path = "comidistar2") # abre nueva ventana
```


También es posible hacerlo usando RStudio (haciendo clicks).


# Explorando el repositorio del proyecto

## Información del paquete: DESCRIPTION

## Dependencias y otras pesadillas: NAMESPACE

## Scripts de R en R/

# Funciones en R y R/

```r
#' Print author
#' @export print_name
#' @usage print_author()
#' @import dplyr
#' @importFrom tidyr drop_na
#' @description Print the name of the author of the package we are developing
#' @param author Name of the package author
#' @author Gonzalo Garcia-Castro
print_name <- function(
    author = "Gon"
){
    print(author)
}
```


# Documentación:

## Documentando las funciones y datos con roxygen2 y document()

```r
library(devtools)

document()
```

## Viñetas y artículos con use_vignette() y use_article()


# Dependencias y otras pesadillas: Parte 2

* Es probable que nuestro paquete use funciones de otros paquetes.
* Debemos indicar qué funciones es necesario importar para hacer funcionar nuestro paquete
* El archivo NAMESPACE contiene esa información. La función `devtools::document()` gestiona NAMESPACE por nosotros
* Aun así, debemos indicar las dependencias de paquetes en DESCRIPTION. `usethis::use_package()` lo hace por nosotros (ej. `use_package("dplyr")`)

NOTA: cuantas menos dependencias, menor probabilidad de nuestro paquete se rompa cuando algún otro paquete se actualiza (CRAN pone un límite de dependencias).


## NAMESPACE, @importFrom y use_package()

## Usando dplyr y use_pipe()


# Datos internos, datos externos, datos brutos

## Datos internos y externos con use_data(), data/

Se guardan como objetos de R (.rds).

* Objeto de R visible: `usethis::use_data(x, internal = FALSE)`, donde `x` es una variable de R (vector, data.frame, list, etc.). Será accesible mediante el operador `::` (ej.,  `elcomidistar::cataaciegas`). Requiere documentación (ver abajo). Se guarda como RDS en la carpeta R/ con el nombre del objeto.
* Objeto de R interno: `usethis::use_data(x, internal = TRUE)`, donde `x` es una variable de R (vector, data.frame, list, etc.). Será accesible mediante el operador `:::` (ej., `elcomidistar::cataaciegas`). Se guarda como `sysdata.rds` en la carpeta R/.

## Datos brutos con use_data_raw() y data_raw/

Archivo *bruto*: TXT, CSV, XLSX, etc. en `inst/`. Al instalar el paquete, los archivos y caeprtas se mueven a la carpeta principal.

# Archivos externos y la carpeta inst/

A veces necesitamos incluir archivos externos en nuestro paquete: datos, scripts de C++, Python, imágenes, etc.
    
Scripts de otras lenguas de programación (Python, Stan, etc...).


# Manteniendo y compartiendo el paquete

## Git y GitHub

Un paquete de R puede volverse complejo en seguida: scripts con muchas funciones, funciones que dependen de otras funciones, funciones dependen de funciones de otros paquetes... Es fácil liarla. Git es una buena herramienta para controlar cómo va cambiando el paquete. Te permite llevar la cuenta de cómo ha cambiado cada archivo dentro del paquete, poder volver a una versión específica del mismo archivo, o tener diferentes versiones del mismo paquete funcionando a la vez de forma independiente. Este último punto es especialmente útil si queremos "jugar" con una versión de prueba del paquete mientras otras personas se pueden descargar una versión estable del mismo.

GitHub es una red social que permite almacenar y compartir repositorios mediante control de versiones en Git^[No es la 'unica: Gitlab y Bitbucket, entre otras, hacen lo mismo, aunque son menos populares. No son propiedad de Microsoft.]. Varias personas pueden acceder al repositorio (un paquete de R, en nuestro caso) y sugerir cambios como si estuvieran trabajando sobre dicho paquete en un sólo ordenador. El mejor manual que conozco (y también el más accesible) para aprender a usar Git y GitHub (especialmente para quien ya trabaja en R) es [*Happy Git and GitHub for the useR*](https://happygitwithr.com/index.html), de Jenny Bryan. Aprender git no siempre es fácil pero siempre merece la pena^[En mi honesta, humilde, ignorable opinión.].

Git y GitHub cumplen una función muy especial para quienes hacemos un paquete en R: la función `install_github`, del paquete {devtools}^[Más que un paquete de R, `devtools` es una collección de funciones de otros paquetes que han sido agrupadas por su utilidad a la hora de desarrollar paquetes ("devtools" es la abreviatura de *developer tools*). La función `install_github` pertenece, originalmente, al paquete {remotes}], permite instalar un paquete sin necesidad de que esté publicado en CRAN. Hablaremos más adelante de CRAN, pero por ahora nos interesa saber que podemos compartir cualquier paquete a través de GitHub usando `install_github`, pero para poder instalarlo usando `install.packages`, como normalmente hacemos, ese paquete necesita estar publicado en CRAN. Publicar en CRAN requiere un proceso de revisión que en ocasiones es díficil solventar (y a veces innecesario). Para compartir nuestro paquete sin necesidad de pasar por ese calvario, lo haremos a través de GitHub.

Para hacerlo, primero debemos crear un usuario de GitHub, crear un nuevo repositorio, hacer click en el botón verde que dice "Code", y copiar el enlace que aparece.

![](img/github_code.png)

En nuestra sesión de R, ejecutamos las siguientes líneas de código:

```r
use_git() # esta línea inicializa Git en el repositorio
use_git_remote(name = "origin", url = "https://github.com/gongcastro/psicotuiteR.git") # sustituye ese link por el que hayas copiado de GitHub
use_github_ignore() # crea un archivo llamado .gitignore que indica a Git qué archivos ignorar
git_vaccinate() # añade más cosas a .gitignore para evitar subir información sensible a GitHub
```

## testthat y test()

Los cambios que introducimos en nuestras funciones de R pueden provocar que fallos que a veces no detectamos inmediatamente. Algunos fallos no producen un error, sino que hacen que nuestras funciones se comporten de forma diferente a la que esperamos. Por ejemplo, un *data.frame* que devuelve nuestra función podría contener una variable con una clase *character* en lugar de *logical*. Este comportamiento indeseado podría pasar desapercibido cuando probemos las funciones que hemos cambiado. Para detectar estos problemas debemos poner a prueba todo el código cada vez que hacemos cambios. Hacer esto de forma manual cada vez puede ser muy tedioso. El paquete {testthat} se encarga de hacer esto por nosotros.

Si ejecutamos `use_testhat`, se creará una carpeta llamada *tests* en nuestro repositorio. Dentro de esta carpeta, hay otra carpeta llamada *testthat*. Cualquier script de R que guardemos en esa carpeta se ejecutará automáticamente cuando ejecutemos `test()` en nuestra consola. Estos scripts deberían seguir tener el siguiente contenido:

```r
test_that("Los datos de clima se cargan correctamente", {expect_error(data("clima"), NA)})
```

En esta línea de código estamos creando un test mediante la función `test_that` (del paquete {testhat}). Primero incluimos un mensaje que indique qué estamos "testeando" en específico (en este caso, que podemos cargar el dataset `clima` sin error. La función `expect_error` ejecuta el código de dentro, y evalúa si el resultado se corresponde con lo que indiquemos en el segundo argumento (en nuestro caso `NA`, que signifique que no hay fallo). Para ver con más detalle cómo poner a prueba el paquete que has creado, y aprender buenas prácticas en este tema puedes ver la documentación del paquete {testhat}.


## CRAN y check()

## Test automatizados con GitHub actions

## Code coverage


# Dejando el paquete guapo y extendiendo la documentación

## Logo con use_log() y Hexmaker

## pkgdown: use_pkgdoown, build_site(), use_github_pages() y use_github_links()

## README: use_read_md(), use_readme_rmd() y build_readme()

## Placas: use_lifecycle(), use_badge() y badges.com

## News con use_news()

## Referencias en la documentación


# Más posibilidades

## Licencias: use_*_license()

## Referencia: use_citation()





## DESCRIPTION

![](img/description.png)

## Git/GitHub

# Carpeta R  y paquete roxygen2: Funciones y documentación

Vamos a crear nuestra función:


```r
#' Importar datos de El Comidista
#' @importFrom dplyr group_by
#' @importFrom dplyr summarise
#' @param data Un data frame con al menos una columna tipo "character" identificando el tipo de producto (llamada "producto"), y una columna tipo "numeric" con la puntuación asignada a cada producto (llamada "puntuacion")
#' @param producto Vector de tipo "character" indicando los tipos de producto para los que se quiere
#' obtener estadísticos descriptivos.
#' @returns Data frame con los estadísticos descriptivos de los datos de El Comidista
#' @examples
#' comidista_agregar_datos(mtcars, producto = "leche")
comidista_agregar_datos <- function(
  data,
  producto = NULL
){
  x <- group_by(data, producto)
  if (!is.null(producto)) x <- filter(x, producto %in% producto)
  x <- summarise(
    data,
    puntuacion_media = mean(puntuacion, na.rm = TRUE),
    puntuacion_sd = sd(puntuacion, na.rm = TRUE)
  )
  return(x)
}
```



# Directorios

# Tests: `testhat::test()` y `devtools::check()`

# Publicación

## pkgdown

## CRAN y otros


